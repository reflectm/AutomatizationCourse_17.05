## Лекция 2. Текстовые файлы. 

### Работа с текстовыми файлами
* Способы взаимодействия с файлами расширения ```.txt```
* Открытие и закрытие файлового дескриптора (функция ```open()``` и метод ```.close()```)
* Модификаторы доступа
* Чтение из файла при помощи ```read(), readline(), readlines()```
* Запись в текстовый файл при помощи ```write(), writelines()```
* Задачи
* Менеджеры контекста ```with``` и методы ```__enter___``` , ```__exit__```

### Шаг 0. Про расширение
```.txt``` - одно из самых старых и простых файловых расширений, которое позволяет хранить тексты (строчные символы) без какой-либо структуры. Именно поэтому данное файловое расширение относят к ***неструктурированным***.

Создадим простейший текстовый файл ```input.txt``` со следующим содержимым:
```
Alexa
Alice
Amazon
Alla
```

### Шаг 1. Способы взаимодействия с текстовыми файлами
В ```Python``` взаимодействие с файлами осуществляется через т.н. файловые-объекты (```...IOWrapper```). Для начала работы с файлом - создадим модуль ```main.py``` в той же директории, где находится ```input.txt``` (это делается для упрощения прописания путей до текстового файла).

* Содержимое ```main.py```
```
"""
Модуль для простейшего взаимодействия с текстовым файлом
"""

FILE_PATH = "input.txt" #Путь до файла (т.к. лежит в той же директории - указывать полный не нужно)

file_handler = None
try:
    file_handler = open(file=FILE_PATH, mode="r") # Пытаемся открыть файл с правами на чтение символов "r" - возвращает файловый объект
except FileNotFoundError as fnfe:
    print(fnfe) # Бросаем исключение, если не получилось проинициализировать объект

if file_handler:
    print(f"File {FILE_PATH} successfully opened!.\nFileHandler object has type {type(file_handler)}\nand val {file_handler}")
    file_handler.close() # Закрываем объект, работа завершена
```

* При открытии дескриптора (вызов open(...)) передается 2 параметра:
    * Путь до файла
    * Режим работы (mode)

* Режимы работы бывают следующие:
    * ```r``` - чтение (запрет на редактирование содержимого)
    * ```w``` - перезапись (полная перезапись содержимого)
    * ```a``` - дозапись (дозапись в файл)
    * ```Xb``` - где ```X``` это либо ```r``` либо ```w``` - используется для работы с бинарными файлами (текстовый файл - не бинарный, поэтому использовать такие режимы мы не будем).
    * Есть еще пара интересных режимов - подробнее тут https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files

* В приведенном выше фрагменте кода работа с файловым объектом очень простая:
    * Открыли
    * Посмотрели на его строковое представление и какому классу он принадлежит
    * Закрыли

***Важно***: не забывайте закрывать дескрипторы после окончания работы с ними. Если будет одновременно открыто множество дескрипторов - есть возможность нарваться на коллизии и конфликты с операционной системой. Данное правило справедливо в принципе для любых файлов и расширений.


***Очень важно***: файловый объект - это вся сущность файла, включая его внутреннее содержание, свойства и прочее или это набор ссылок и свойств верхнего уровня? Попробуйте выполнить следующие действия с файлом ```large.txt``` (файл состоит из большого количество строк с символом #):
```
"""
Модуль  демонстрирующий разницу в байтовом
размере объекта и исходного файла
"""
from pathlib import Path

pure_file_handler_object = open("large.txt" , "r")

print(f"Size of pure file handler object is {pure_file_handler_object.__sizeof__()} bytes")
print(f"Size of file {Path('large.txt').stat().st_size }bytes")

pure_file_handler_object.close()

```

Вывод примерно следующий:
```
Size of pure file handler object is 192 bytes
Size of file 522956337 bytes
```

Из этого следует, что ***файловый объект выступает в качестве ссылки на исходник***, через который в дальнейшем будем производится работа с внутренностью файла.


### Шаг 2. Чтение из файла
* Для того, чтобы вычитать из текстового файла данные необходимо:
    * Инициализировать файловый объект с режимом "r"
    * Воспользоваться одним из методов объекта : ```read(), readline(), readlines()```

В качестве основы возьмем файл ```input.txt```, который уже использовался ранее. Рассмотрим пример:
```
"""
Модуль , демонстрирующий особенности работы с файловым
объектом при чтении данных
"""

def read_full(file_handler):
    """
    Считывает весь файл целиком в виде одной большой строки
    """
    return file_handler.read()


def read_line_by_line(file_handler):
    """
    Считывает файл построчно
    На каждый вызов метода считывается ровно одна строка
    """
    lines = []
    lines.append(file_handler.readline()) # Считает "Alexa"
    lines.append(file_handler.readline()) # Считает "Alice"
    lines.append(file_handler.readline()) # Считает "Amazon"
    lines.append(file_handler.readline()) # Считает "Alla"
    lines.append(file_handler.readline()) # Не понятно, что считает, т.к. файл кончился
    lines.append(file_handler.readline()) # Не понятно, что считает, т.к. файл кончился
    return lines

def read_lines(file_handler):
    """
    Считывает весь файл целиком в виде списка строк
    """
    return file_handler.readlines()


def main():
    """
    Основная точка входа для 3 запусков:
    * Считваем все одной строкой
    * Считываем все построчно
    * Считываем все списком строк
    """

    fh1 = open("input.txt", "r")
    print("read_full() : ", read_full(fh1))
    fh1.close()

    fh2 = open("input.txt", "r")
    print("read_line_by_line():", read_line_by_line(fh2))
    fh2.close()

    fh3 = open("input.txt", "r")
    print("read_lines():", read_lines(fh3))
    fh3.close()

if __name__ == '__main__':
    main()
```

* Обратите внимание, что после каждого вызова считывающей функции в коде закрывается файловый объект и создается новый. Дело в том, что если продолжать считывание на одном файловыом объекте - то последующие считывания начинаются с того места, где остановился предыдущий сеанс чтения над этим объектом.

* Запустив данный код вы увидите основную разницу между способами вычитывания данных из текстового файла (обратите внимание на символы переноса строки, которые находятся у строк, а также на символы пустых строк - как знак того, что файл пуст).

* Когда что использовать?
    * Если в текстовом файле лежит простая строка (или простейший набор), который затем без труда может быть разобран на части - используйте .read()
    * Если файл очень большой - лучше считывать построчно ```readline()``` в цикле ```while``` (условие - считанная строка != пустой)
    * Если файл не слишком большой - но удобнее обрабатывать строки по отдельность - ```readlines()```

* Вариант с построчным считыванием:
```
def read_line_by_line(file_handler):
    """
    Считывает файл построчно
    На каждый вызов метода считывается ровно одна строка
    """
    lines = []
    line = file_handler.readline()
    while line != "":
        lines.append(line)
        line = file_handler.readline()
    return lines
```

***Важно*** - при работе с файлом на чтение ***ОБЯЗАТЕЛЬНО*** наличие файла, иначе будет выброшено исключение. При работе с файлом на запись (перезапись/дозапись) - файл может быть создан автоматически.

### Шаг 3. Запись в файл
* При работе с текстовым файлом (при записи) есть 2 варианта:
    * Открыть файловый объект и перезаписать его полностью - режим ```"w"```
    * Открыть файловый обхект и дозаписать в него - режим ```"a"```

***Важно*** - при добавлении элементов в текстовый файл не забывать добавлять символы переноса на новую строку ```\n``` , т.к. за вас это никто делать не будет! (При создании файла в редакторе мы жмем клавишу ```Enter```, которая и является этим самым символом, но редактор его нам не показывает в явном виде, а вместо этого - перебрасывает нас на новую строку).

* Рассмотрим следующий пример:
```
"""
Модуль, демонстрирующий как работает перезапись 'w'
"""

NAMES = ["Alice", "Bob", "Alex"]

file_handler = open("output.txt", "w")
for name in NAMES:
    file_handler.write(name)

file_handler.close()
```
* Обратите внимание на внутреннее состояние файла ```output.txt```. Попробуйте изменить имена в списке ```NAMES``` и заново запустить код. Произойдет полная перезапись.

* Пример с переносами на новую строку:
```
"""
Модуль, демонстрирующий как работает перезапись 'w'
"""

NAMES = ["Alice", "Bob", "Alex"]

file_handler = open("output.txt", "w")
for name in NAMES[:-1]:
    file_handler.write(name + "\n") # Добавит Alice\n и Bob\n
file_handler.write(NAMES[-1]) # Добавит Alex

file_handler.close()
```

* Пример с записью не строковых объектов (метод write() и writelines() требует, чтобы записывались именно объекты типа string)
```
"""
Модуль, демонстрирующий как работает перезапись 'w'
"""

AGES = [10, 12, 14, 13, 15, 11] # Возраст каких-либо учеников средней школы

file_handler = open("output.txt", "w")
for age in AGES[:-1]:
    file_handler.write(str(age) + "\n") # Добавит 10\n , 12\n и т.д.
file_handler.write(str(AGES[-1])) # Добавит 11

file_handler.close()
```
* Попробуйте убрать приведение типа через ```str()``` и посмотрите, что получится. Должно быть ```TypeError: write() argument must be str, not int```

* Аналогично те же самые действия можно выполнить с методом ```writelines()``` - запишет весь списк строк в файл
```
"""
Модуль, демонстрирующий как работает перезапись 'w'
"""

AGES = [10, 12, 14, 13, 15, 11] # Возраст каких-либо учеников средней школы

file_handler = open("output.txt", "w")
file_handler.writelines([str(age) +"\n" for age in AGES[:-1]]) # Превращаем список в ["10\n", "12\n", "14\n", ... , "15\n"]
file_handler.write(str(AGES[-1])) # Дозаписываем последний "11"
file_handler.close()
```

* ***Дозапись*** - изменим лишь режим файлового объекта ```"a"```
```
"""
Модуль, демонстрирующий как работает дозапись 'a'
"""

AGES = [10, 12, 14, 13, 15, 11] # Возраст каких-либо учеников средней школы

file_handler = open("output.txt", "a")
file_handler.writelines([str(age) +"\n" for age in AGES[:-1]]) # Превращаем список в ["10\n", "12\n", "14\n", ... , "15\n"]
file_handler.write(str(AGES[-1])) # Дозаписываем последний "11"
file_handler.close()
```

* Как видите, произошло добавление в конец файла (точнее , в то место, где стоял последний символ).


### Шаг 4. Менеджер контекста
* ```with``` - оператор контекстного менеджера, который позволяет немного облегчить работу с файловыми объектами:
```
"""
Модуль, демонстрирующий способ
работы с файловыми объектами
через with
"""

FILE_PATH = "input.txt"
with open(FILE_PATH, "r") as file_handler:
    print(file_handler.read())
```

* Обратите внимание , что теперь закрывать файловый объект не нужно - контекстный менеджер ```with``` делает эту работу за нас! Как же он работает? Рассмотрим простой пример:
```
"""
Как работает контекстный менеджер
"""

class Person:
    def __init__(self, name:str="sample"):
        self.name = name

    def __enter__(self):
        print("I am __enter__! Start working on it!")
        return self.name

    def __exit__(self, *args):
        print("I am __exit__! Finished!")


with Person("Bob") as something:
    print(something)

```
* Как вы видите (после запуска кода), то первым делом , после создания объекта, у него вызывается метод ```__enter__```, котоырй возвращает что-то (на самом деле это может быть что угодно - это значение будет использовано внутри контекста ```with```). А после завершения теля контекста - вызывается метод ```__exit__``` (его сигнатура весьма специфична, т.к. при завершении могут быть переданы еще различные наборы параметров - поэтому принято ставит континуальный аргумент ```*args```).

### Шаг 5. Итоговый файловый обработчик
* После всего вышеизложенного предлагается рассмотреть следующий участок когда, который позволяет единвоременно работать с двумя файловыми объектами (их может быть какое угодно количество)
```
"""Модуль, содержащий сложный менеджер файловых объектов."""
from pathlib import Path


class CustomFileManager:
    """Класс, описывающий суть комплексного менеджера.

    * file_in - входной файл (путь до входного файла)
    * file_out - выходной файл (путь до выходного файла)
    * out_mode - режим работы с выходым файлом (по умолчанию - перезапись)
    """

    def __init__(
        self,
        file_in: str = "input.txt",
        file_out: str = "output.txt",
        out_mode: str = "w",
    ):
        self.file_in = file_in
        self.file_out = file_out
        self.out_mode = out_mode
        self.build_handlers()

    def build_handlers(self):
        """
        Метод, проверяющий что file_in - существует
        и добавляющий 2 атрибута объекту
        """
        if Path(self.file_in).exists():
            self.file_in_handler = open(self.file_in, "r")
            self.file_out_handler = open(self.file_out, self.out_mode)

        else:
            raise FileNotFoundError(f"File {self.file_in} does not exists!")

    def __enter__(self):
        """Возвращает пару из двух файловых объектов."""
        return (self.file_in_handler, self.file_out_handler)

    def __exit__(self, *args):
        """Закрывает файловые объекты."""
        self.file_in_handler.close()
        self.file_in_handler.close()


with CustomFileManager() as handlers:
    input_handler, output_handler = handlers
    data = input_handler.read()
    output_handler.write(data)

print("Done!")

```

* Банально и просто - представленный мендежер файловых объектов инициализирует 2 внутренних файловых объекта (один на запись, другой на чтение) , а затем используется еще проще - вычитываем все из одного и записываем в другой). Как видите, теперь не нужно тащить за собой большую часть различных файловых объектов, а можно их сагрегировать внутри единого общего файлового объекта, который мы смогли собрать , используя базовые знания про работу ```with```.


### Итог
* Файловый объект является ссылкой на исходный файл (т.е. сам файл изначально при инициализации объекта в память не подгружается)
* При повторном чтении над файловым объектом - следующее считывание начинается с места, где остановилось предыдущее. Если нужно заново пройти по файлу - придется заново создавать файловый объект, а предыдущий закрыть.
* Если нужно записать в файл, то есть 2 варианта:
    * "w" - режим ***ПЕРЕЗАПИСИ***
    * "a" - режим ***ДОЗАПИСИ***

* Запись в файл происходит посредством использования методов ```write()``` и ```writelines()```
* Метод ```write(arg)``` требует, чтобы ```arg``` был типом ```string```
* Метод ```writelines(list)``` требует, чтобы все элементы ```list``` были типа ```string```.
* ```with``` - менеджер контекста, позволяющий в исходной постановке ```with open(...) as fh:``` не заботиться о закрытии файлового объекта. Файловый объект будет существовать (таким образом) только внутри блока ```with```.

* Добавляя методы ```__enter__``` и ```__exit__``` в любой пользовательский класс - объекты данного класса могут быть также использованы как агрегаторы контекста - при инициализиации контекста вызывается метод ```__enter__```, при выходе из контекста ```__exit__```.
